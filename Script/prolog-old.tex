\chapter{Logisches Programmieren} 
Im diesem Kapitel wollen wir uns mit dem logischen Programmieren beschäftigen.
Wir setzen uns zunächst mit den theoretischen Grundlagen auseinander und stellen dann
die Programmiersprache Prolog vor.

\section{Theoretische Grundlagen}
\begin{Definition}[Programm--Klausel]
{\em
    Eine prädikatenlogische Klausel $k$ ist eine \emph{Programm--Klausel} wenn sie
    genau ein positives Literal enthält.
} \hspace*{\fill} $\Box$
\end{Definition}

Nach der obigen Definition ist eine Klausel $k$ also eine Programm--Klausel wenn einer
der folgenden Fälle vorliegt:
\begin{enumerate}
\item $k$ enthält genau ein positives Literal und keine negativen Literale.  
      $k$ hat dann die Form \\[0.1cm]
      \hspace*{1.0cm} $k = p(s_1, \cdots, s_m)$.

      In diesem Fall bezeichnen wir $k$ als \emph{Fakt}.
\item $k$ enthält genau ein positives Literal und $n>0$ negative Literale. Dann hat $k$
      die Form \\[0.1cm]
      \hspace*{1.0cm}
            $k = p\big(s_1, \cdots, s_m\big) \vee \neg p_1\big(s^{(1)}_1, \cdots, s^{(1)}_{m(1)}\big) \vee \cdots \vee \neg p_n(s^{(n)}_1, \cdots, s^{(n)}_{m(n)}\big)$.

      In diesem Fall bezeichnen wir $k$ als \emph{Regel}.
\end{enumerate}
Aufgrund der Äquivalenz $(\neg p \vee q) \leftrightarrow (p \rightarrow q)$ und 
$\neg (p \wedge q) \leftrightarrow (\neg p \vee \neg q)$ kann eine
Programm--Klausel der Form \\[0.1cm]
\hspace*{1.3cm} 
$p\big(s_1, \cdots, s_m\big) \vee \neg p_1\big(s^{(1)}_1, \cdots, s^{(1)}_{m(1)}\big) \vee \cdots \vee \neg p_n(s^{(n)}_1, \cdots, s^{(n)}_{m(n)}\big)$ \\[0.1cm]
umgeschrieben werden zu \\[0.1cm]
\hspace*{1.3cm} 
$p_1\big(s^{(1)}_1, \cdots, s^{(1)}_{m(1)}\big) \wedge \cdots \wedge p_n(s^{(n)}_1, \cdots, s^{(n)}_{m(n)}\big) \rightarrow p\big(s_1, \cdots, s_m\big)$ \\[0.1cm]
Im Kontext des logischen Programmierens drehen wir hier den Implikationspfeil
``$\rightarrow$'' noch um und schreiben dann \\[0.1cm]
\hspace*{1.3cm} 
$p\big(s_1, \cdots, s_m\big) \leftarrow p_1\big(s^{(1)}_1, \cdots, s^{(1)}_{m(1)}\big) \wedge \cdots \wedge p_n(s^{(n)}_1, \cdots, s^{(n)}_{m(n)}\big)$.  \\[0.1cm]
Wir nennen $p\big(s_1, \cdots, s_m\big)$ den \emph{Kopf} dieser Klausel und bezeichnen \\[0.1cm]
\hspace*{1.3cm} $p_1\big(s^{(1)}_1, \cdots, s^{(1)}_{m(1)}\big) \wedge \cdots \wedge p_n(s^{(n)}_1, \cdots, s^{(n)}_{m(n)}\big)$ \\[0.1cm]
als den \emph{Rumpf} der Klausel.

\begin{Definition}[Logisches Programm, Ziel] \hspace*{\fill} \\
{\em
    Ein \emph{logisches Programm} ist eine Menge von Programm--Klauseln.  

Eine Formel der Form \\[0.1cm]
\hspace*{1.3cm} 
$G = p_1\big(s^{(1)}_1, \cdots, s^{(1)}_{m(1)}\big) \wedge \cdots \wedge p_n(s^{(n)}_1, \cdots, s^{(n)}_{m(n)}\big)$ \\[0.1cm]
bezeichnen wir als ein \emph{Ziel}.  Falls $n=0$ ist schreiben wir $G = \verum$.
} \hspace*{\fill} $\Box$
\end{Definition}

Beim logischen Programmieren ist ein Ziel $G$ und eine Menge
$\mathcal{P}$ von Programm--Klauseln gegeben.  Die Frage ist dann, ob es eine Substitution $\sigma$ gibt, so dass \\[0.1cm]
\hspace*{1.3cm} $\mathcal{P} \models G\sigma$ \\[0.1cm]
gilt. Falls diese Frage mit ja beantwortet wird, soll zusätzlich eine Substitution $\sigma$ mit der obigen Eigenschaft
berechnet werden.
Wir geben nun ein Verfahren an, mit dem die Frage, ob  $\mathcal{P} \models G\sigma$ gilt, untersucht werden kann und mit dem zusätzlich
die Substitution $\sigma$, falls sie existiert, berechnet werden kann.  Dazu führen wir zunächst den folgenden Begriff
ein.

\begin{Definition}[Instantiiertes Ziel]
{\em
    Ein Paar der Form \\[0.1cm]
    \hspace*{1.3cm} $\langle A_1 \wedge \cdots \wedge A_m, \sigma \rangle$ \\[0.1cm]
    bezeichnen wir als {\em instantiiertes Ziel} falls
    \begin{enumerate}
    \item $A_1  \wedge \cdots \wedge A_m$ ein Ziel und
    \item $\sigma$ eine Substitution ist. \hspace*{\fill} $\Box$
    \end{enumerate}
}
\end{Definition}
Wie interpretieren ein instantiiertes Ziel $\langle A_1 \wedge \cdots \wedge A_m, \sigma \rangle$ als die Formel \\[0.1cm]
\hspace*{1.3cm} $A_1\sigma \wedge \cdots \wedge A_n\sigma$. \\[0.1cm]
Wir trennen hier die Formel von der Substitution, weil wir dadurch in der Lage sind,
mit den Substitutionen zu rechnen.  Dazu führen wir 
für ein gegebenes logisches Programm $\mathcal{P}$
eine Reduktions--Relation $\leadsto_\mathcal{P}$ ein.
Mit dieser Reduktions--Relation können wir später instantiierte Ziele vereinfachen.

Um diese Relation definieren zu können, führen wir noch den Begriff der Einschränkung einer
Substitution $\sigma$ auf eine Menge von Variablen ein.

\begin{Definition}[$\sigma \restriction V$]
{\em
  Es sei $\sigma = [ x_1 \mapsto s_1, \cdots, x_n \mapsto s_n ]$ eine Substitution und $V$ sei eine Menge von Variablen.
  Um die Einschränkung von $\sigma$ auf $V$ definieren zu können, erinnern wir uns, dass Substitutionen
  als Mengen von Paaren definiert sind.  Es gilt \\[0.1cm]
  \hspace*{1.3cm} $\sigma = \big\{ \langle x_1, s_1 \rangle, \cdots, \langle x_n, s_n \rangle \big\}$ \\[0.1cm]
  Dann definieren wir die \emph{Einschränkung von $\sigma$ auf $V$} als  \\[0.1cm]
  \hspace*{1.3cm} $\sigma \restriction V := \big\{ \langle x, s \rangle\in \sigma \; \big|\; x \in V \big\}$.
  \hspace*{\fill} $\Box$
}
\end{Definition}
Die Idee hinter der Definition von $\sigma\restriction V$ ist, dass wir nur an dem Verhalten von $\sigma$ auf
den Variablen aus $V$ interessiert sind, der Rest interessiert uns nicht.  
\vspace{0.1cm}

\noindent
\textbf{Beispiel}: Es sei $\sigma := [ x \mapsto c, y \mapsto f(d), z \mapsto d ]$ und $V := \{ x, z \}$.
Dann haben wir \\[0.1cm]
\hspace*{1.3cm} $\sigma\restriction V = [ x \mapsto c, z \mapsto d ]$ \hspace*{\fill} $\Box$
\vspace{0.1cm}

Wir haben jetzt alles Material
zusammen, um die Reduktions--Relation $\leadsto_\mathcal{P}$ definieren zu können.

\begin{Definition}[$\leadsto_\mathcal{P}$]
{\em 
 Es gelte:
\begin{enumerate}
\item $\langle A_1 \wedge \cdots \wedge A_m, \sigma \rangle$ ist ein instantiiertes Ziel.
\item $\mathcal{P}$ ist ein logisches Programm,
\item $H \leftarrow B_1 \wedge \cdots \wedge B_n$ ist eine Programm--Klausel aus $\mathcal{P}$.

      Hier lassen wir den Fall $n=0$ zu.  Dann hat die Programm--Klausel einfach die Form $H$, wobei $H$ ein Fakt ist.
\item $\pi$ ist eine Variablen--Umbenennung. $\pi$ ist so gewählt, dass \\[0.1cm]
      \hspace*{1.3cm} $\FV\big(H\pi \leftarrow B_1\pi \wedge \cdots \wedge B_n\pi\big) \;\cap\; \FV\big(A_1\sigma \wedge \cdots \wedge A_m\sigma \big) = \emptyset$ \\[0.1cm]
      gilt. Also sind die Variablen, die in der Klausel
      $H\pi \leftarrow B_1\pi \wedge \cdots \wedge B_n\pi$ vorkommen, verschieden von den
      Variablen, die in dem Ziel \\
      $A_1\sigma \wedge \cdots \wedge A_m\sigma$ vorkommen.
\end{enumerate}
Ist dann die syntaktische Gleichung $A_1\sigma \doteq H\pi$ lösbar und ist $\mu = \textsl{mgu}(A_1\sigma, H\pi)$, so setzen wir $\tau := \mu \restriction \FV(A_1)$
und definieren \\[0.1cm]
\hspace*{1.3cm} 
$\big\langle A_1 \wedge \cdots \wedge A_m, \sigma \big\rangle \leadsto_\mathcal{P} \big\langle B_1\pi\mu \wedge \cdots \wedge B_n\pi\mu \wedge A_2 \wedge \cdots \wedge A_m, \sigma\tau \big\rangle$ 
} \hspace*{\fill} $\Box$
\end{Definition}

Wir definieren den reflexiven und transitiven Abschluss $\leadsto_\mathcal{P}^*$ der Relation $\leadsto_\mathcal{P}$ in der üblichen Art und Weise:
\begin{enumerate}
\item Es gilt $\langle A_1 \wedge \cdots \wedge A_m, \sigma \rangle \leadsto_\mathcal{P}^* \langle A_1 \wedge \cdots \wedge A_m, \sigma \rangle$.
\item Aus \\[0.1cm]
     \hspace*{1.3cm}  $\langle A_1 \wedge \cdots \wedge A_m, \sigma \rangle \leadsto_\mathcal{P} \langle B_1 \wedge \cdots \wedge B_n, \tau \rangle$ \\[0.1cm]
     und \\[0.1cm]
     \hspace*{1.3cm}  $\langle B_1 \wedge \cdots \wedge B_n, \tau \rangle \leadsto_\mathcal{P}^* \langle C_1 \wedge \cdots \wedge C_o, \varrho \rangle$ \\[0.1cm]
     folgt \\[0.1cm]
     \hspace*{1.3cm}  $\langle A_1 \wedge \cdots \wedge A_m, \sigma \rangle \leadsto_\mathcal{P}^* \langle C_1 \wedge \cdots \wedge C_o, \varrho \rangle$.
\end{enumerate}


Welche Eigenschaft hat die Reduktions--Relation $\leadsto_\mathcal{P}^*$? Falls \\[0.1cm]
\hspace*{1.3cm} $\langle A_1 \wedge \cdots \wedge A_m, \sigma \rangle \leadsto_\mathcal{P}^* \langle B_1 \wedge \cdots \wedge B_n, \tau \rangle$ \\[0.1cm]
gilt, haben wir das Folgende:
\begin{enumerate}
\item Es gibt eine Substitution $\varrho$, so dass $\tau = \sigma\varrho$ ist.
\item $\mathcal{P} \cup \big\{ B_1\tau \wedge \cdots \wedge B_n\tau \big\} \models A_1\tau \wedge \cdots \wedge A_m\tau$
\end{enumerate}
Diese Eigenschaft kann durch Induktion nach der Definition von $\leadsto_\mathcal{P}^*$ bewiesen werden.  Der für uns wichtigste Fall ist der, dass
$\sigma = []$ und $n = 0$ ist, dass also
\hspace*{1.3cm} $\langle A_1 \wedge \cdots \wedge A_m, [] \rangle \leadsto_\mathcal{P}^* \langle \verum, \tau \rangle$ \\[0.1cm]
gilt.  Diesen Fall halten wir in dem folgenden Satz fest.

\begin{Satz}  \label{satz:prolog-korrekt}
{\em
Falls   $\langle A_1 \wedge \cdots \wedge A_m, [] \rangle \leadsto_\mathcal{P}^* \langle \verum, \tau \rangle$ gilt, dann haben wir \\[0.1cm]
\hspace*{1.3cm}  $\mathcal{P} \models A_1\tau \wedge \cdots \wedge A_m\tau$. 
}
\hspace*{\fill} $\Box$
\end{Satz}

Dieser Satz liefert uns ein Verfahren, um für ein gegebenes Ziel der Form \\ $A_1 \wedge \cdots \wedge A_m$ 
eine Substitution $\tau$ zu berechnen, so dass \\[0.1cm]
\hspace*{1.3cm} $\mathcal{P} \models A_1\tau \wedge \cdots \wedge A_m\tau$ \\[0.1cm]
gilt:  Wir starten mit dem instantiierten Ziel $\langle A_1 \wedge \cdots \wedge A_m, []\rangle$ und formen dies mit Hilfe
der Reduktions--Relation $\leadsto_\mathcal{P}$ so lange um, bis wir bei einem Ziel der Form $\langle \verum, \tau\rangle$ angekommen
sind.  Die so erhaltene Substitution $\tau$ leistet dann das gewünschte.
\vspace{0.3cm}

\noindent
\textbf{Beispiel}: Wir erweitern die Signatur $\Sigma_\mathbb{N}$ aus dem letzten Kapitel so, dass gilt: \\[0.1cm]
\hspace*{1.3cm} 
\hspace*{1.3cm} $\Sigma_\mathbb{N} := \langle \mathbb{T}, \textsl{Fz}, \textsl{Pz}, \mathtt{sign}_{F}, \mathtt{sign}_{P}, \mathcal{V}, \textsl{var} \rangle$ \\[0.1cm]
mit
\begin{enumerate}
\item $\mathbb{T} := \{ \mathbb{B}, \mathbb{N} \}$.
\item $\textsl{Fz} := \{ s \}$ mit $0: \mathbb{N}$ und $s: \mathbb{N} \rightarrow \mathbb{N}$.
\item $\textsl{Pz} := \{ <, \textsl{plus} \}$ mit $<: \mathbb{N} \times \mathbb{N} \rightarrow \mathbb{B}$ und $\textsl{plus}: \mathbb{N} \times \mathbb{N} \times \mathbb{N} \rightarrow \mathbb{B}$.
\end{enumerate}
Wir wollen den Term $s(x)$ als $x+1$ interpretieren und
unsere Intention bei dem Prädikats--Zeichen ``$\textsl{plus}$'' ist, 
dass $\textsl{plus}(x,y,z)$ genau dann wahr ist, wenn $z$ die Summe von $x$ und $y$ ist.
Wir definieren ein logisches Programm $\mathcal{P}$ wie folgt: \\[0.1cm]
\hspace*{1.3cm} $\mathcal{P} := \big\{ \textsl{plus}(x,0,x),\; \textsl{plus}(x,s(y),s(z)) \leftarrow \textsl{plus}(x,y,z) \big\}$. \\[0.1cm]
Wir stellen die Frage, für welches $u$ \\[0.1cm]
\hspace*{1.3cm} $\mathcal{P} \models \textsl{plus}(s(0), s(s(0)), u)$ \\[0.1cm]
gilt.  Wir versuchen also als erstes, das instantiierte Ziel \\[0.1cm]
\hspace*{1.3cm} $Z_1 := \big\langle \textsl{plus}(s(0), s(s(0)), u), [] \big\rangle$ \\[0.1cm]
zu reduzieren.  Die einzige Klausel, deren Kopf mit $\textsl{plus}(s(0), s(s(0)), u)$ unifizierbar ist, ist die Klausel \\[0.1cm]
\hspace*{1.3cm} $\textsl{plus}(x,s(y),s(z)) \leftarrow \textsl{plus}(x,y,z)$ \\[0.1cm]
Wir betrachten also die syntaktische Gleichung \\[0.1cm]
\hspace*{1.3cm} $\textsl{plus}(s(0), s(s(0)), u) \doteq \textsl{plus}(x,s(y),s(z))$ \\[0.1cm]
Diese syntaktische Gleichung hat die allgemeinste Lösung \\[0.1cm]
\hspace*{1.3cm}  $\mu_1 := [ x \mapsto s(0), y \mapsto s(0), u \mapsto s(z) ]$ \\[0.1cm]
Da außerdem $\mu_1 \restriction \{u\} = [ u \mapsto s(z)]$ ist haben wir also \\[0.1cm]
\hspace*{1.3cm} $Z_1 \leadsto_\mathcal{P} Z_2 := \langle \textsl{plus}(s(0),s(0),z), [ u \mapsto s(z) ] \rangle$. \\[0.1cm]
Die einzige Klausel, deren Kopf mit $\textsl{plus}(s(0),s(0),z)$ unifizierbar ist, ist die zweite Klausel.
Da diese Klausel ebenfalls die Variable $z$ enthält, müssen wir diese noch umbenennen, bevor wir die Unifikation durchzuführen.
Ersetzen wir $z$ durch $v$, so  führt uns das auf  die syntaktische Gleichung \\[0.1cm]
\hspace*{1.3cm} $\textsl{plus}(s(0),s(0),z) \doteq \textsl{plus}(x,s(y),s(v))$ \\[0.1cm]
Die allgemeinste Lösung dieser Gleichung lautet \\[0.1cm]
\hspace*{1.3cm} $\mu_2 = [ x \mapsto s(0), y \mapsto 0, z \mapsto s(v)]$ \\[0.1cm]
Da $\mu_2 \restriction \{z\} = [ z \mapsto s(v) ]$ ist, haben wir \\[0.1cm]
\hspace*{1.3cm} $Z_2 \leadsto_\mathcal{P} Z_3 := \langle \textsl{plus}(s(0), 0, v), [u \mapsto s(s(v)), z \mapsto s(v)]\rangle$. \\[0.1cm]
Mit der atomaren Formel $\textsl{plus}(s(0), 0, v)$ lässt sich jetzt nur der Kopf der
ersten Klausel aus $\mathcal{P}$ unifizieren.  Das liefert die syntaktische Gleichung \\[0.1cm]
\hspace*{1.3cm} $\textsl{plus}(s(0), 0, v) \doteq \textsl{plus}(x,0,x)$. \\[0.1cm]
Die allgemeinste Lösung dieser Gleichung lautet \\[0.1cm]
\hspace*{1.3cm} $\mu_3 = [ x \mapsto s(0), v \mapsto s(0)]$. \\[0.1cm]
Wir haben $\mu_3 \restriction \{v\} = [ v \mapsto s(0) ]$.  Damit gilt \\[0.1cm]
\hspace*{1.3cm} $Z_3 \leadsto_\mathcal{P} Z_4 := \big\langle \verum, [u \mapsto s(s(s(0))), z \mapsto s(s(0)), v \mapsto s(0)] \big\rangle$. \\[0.1cm]
Die durchgeführte  Rechnung zeigt also, dass \\[0.1cm]
\hspace*{1.3cm} $\mathcal{P} \models \textsl{plus}\big(s(0), s(s(0)), u\big)$ \\[0.1cm]
für $u = s(s(s(0)))$ gilt.   Dies zeigt, dass die Relation $\leadsto_\mathcal{P}$ benutzt
werden kann, um Rechnungen durchzuführen: Wir haben oben nämlich die Summe von $1$ und $2$ berechnet.
Ok, dieses Beispiel ist nicht besonders gigantisch und vielleicht hätte der eine oder andere von Ihnen das 
(mit Hilfe eines Taschenrechners) auch herausbekommen.
 Eindrucksvoll werden die Beispiele erst, wenn die Programme und 
die Reduktionen komplexer werden.  Dann macht es zwar keine Freude mehr, die Reduktionen von Hand durchzuführen,
aber das ist auch gar nicht nötig, denn mit der Programmiersprache Prolog gibt es ein mächtiges Werkzeug,
was diese Rechnungen für uns übernehmen kann.  Wir werden diese Programmiersprache in den
nächsten Abschnitten vorstellen.

\section{Prolog --- Die Syntax}
Wir betrachten zunächst die Syntax von Prolog.
Prolog ist (leider) eine ungetypte Sprache, das heißt dass es neben dem Typ--Bezeichner
$\mathbb{B}$ nur noch einen weiteren Typ--Bezeichner gibt.  Um Variablen, und
Funktions--Zeichen und Prädikats--Zeichen
von einander unterscheiden zu können, wird in Prolog folgende Vereinbarung getroffen. 
Variablen sind alle Wörter, die aus Buchstaben, Ziffern und dem Zeichen ``\texttt{\_}''
bestehen und die zusätzlich mit einem Großbuchstaben oder mit dem Zeichen ``\texttt{\_}''
beginnen.  Die folgenden Wörter sind also Beispiele für Prolog Variablen: 
\\[0.1cm]
\hspace*{1.3cm} ``\texttt{X}'', ``\texttt{\_}'', ``\texttt{A\_Long\_Variable\_Name}'',
                ``\texttt{ABC}'', ``\texttt{Y1}'', ``\texttt{Head}'', \\[0.1cm]
\hspace*{1.3cm} ``\texttt{Tail}'', ``\texttt{\_Y}'', ``\texttt{\_another\_Var}''. \\[0.1cm]
In Prolog werden Funktions--Zeichen und Prädikats--Zeichen nicht unterschieden.
Funktions--Zeichen sind alle Wörter, die aus Buchstaben, Ziffern und dem Zeichen ``\texttt{\_}''
bestehen und die mit einem kleinen Buchstaben anfangen.  Außerdem sind Wörter, die in
einfachen Hochkommas eingeschlossen sind, Funktions--Zeichen.  Zusätzlich gibt es einige
vordefinierte Funktions--Zeichen, die aus \emph{Operator--Symbolen} aufgebaut sind.
Hier handelt es sich um die Funktions--Zeichen \\[0.1cm]
\hspace*{1.3cm} 
``\texttt{+}'',
``\texttt{-}'',
``\texttt{*}'',
``\texttt{/}'',
``\texttt{.}''. \\[0.1cm]
Zusätzlich werden \\[0.1cm]
\hspace*{1.3cm} 
``\texttt{<}'',
``\texttt{>}'',
``\texttt{=}'',
``\texttt{=<}'',
``\texttt{>=}'' \\[0.1cm]
als Prädikats--Zeichen benutzt.  Schließlich können als 0--stellige Funktions--Zeichen auch
Zahlen verwendet werden.
Beispiele für Funktions--Zeichen sind also folgende: \\[0.1cm]
\hspace*{1.3cm}  ``\texttt{abc2}'', ``\texttt{a\_XY}'', ``\texttt{etc}'', ``\texttt{x}'', ``\texttt{q}'', 
                 ``\texttt{q2}'', ``\texttt{+}'', ``\texttt{=<}'', ``\texttt{'ab +-'}''. \\[0.1cm]
Eine Programm--Klausel der Form \\[0.1cm]
\hspace*{1.3cm} 
$p\big(s_1, \cdots, s_m\big) \leftarrow p_1\big(s^{(1)}_1, \cdots, s^{(1)}_{m(1)}\big) \wedge \cdots \wedge p_n(s^{(n)}_1, \cdots, s^{(n)}_{m(n)}\big)$.  \\[0.1cm]
wird in Prolog wie folgt geschrieben: \\[0.1cm]
\hspace*{1.3cm} 
$p\big(s_1, \cdots, s_m\big)$ \texttt{:-} $p_1\big(s^{(1)}_1, \cdots, s^{(1)}_{m(1)}\big)$\texttt{,} $\cdots$\texttt{,} $p_n(s^{(n)}_1, \cdots, s^{(n)}_{m(n)}\big)$.  \\[0.1cm]
Der Pfeil ``$\leftarrow$'' wird also durch ``\texttt{:-}'' ersetzt und für das
Symbol ``$\wedge$'' wird einfach ein Komma geschrieben.  Außerdem ist noch wichtig, dass
jede Klausel durch einen Punkt abgeschlossen wird.

Ein Ziel der Form \\[0.1cm]
\hspace*{1.3cm} $p_1\big(s^{(1)}_1, \cdots, s^{(1)}_{m(1)}\big) \wedge \cdots \wedge p_n(s^{(n)}_1, \cdots, s^{(n)}_{m(n)}\big)$ \\[0.1cm]
wird in Prolog als \\[0.1cm]
\hspace*{1.3cm} $p_1\big(s^{(1)}_1, \cdots, s^{(1)}_{m(1)}\big)\mathtt{,}\; \cdots\mathtt{,}\; p_n(s^{(n)}_1, \cdots, s^{(n)}_{m(n)}\big)$. \\[0.1cm]
geschrieben.  Auch hier wird  also das Symbol ``$\wedge$'' durch ein Komma ersetzt und das
Ziel wird durch einen Punkt abgeschlossen.

Ein Beispiel für ein Prolog--Programm finden Sie hier:
\begin{verbatim}
    gallier(asterix).
    gallier(obelix).

    stark(X) :- gallier(X).

    maechtig(X) :- stark(X).
    maechtig(X) :- kaiser(X).

    kaiser(caesar).
    roemer(caesar).

    spinnt(X) :- roemer(X).
\end{verbatim}
Ein Ziel für dieses Prolog--Programm wäre z.B.\\[0.1cm]
\hspace*{1.3cm} \texttt{maechtig(X), spinnt(X).} \\[0.1cm]
In diesem Beispiel sind die Wörter ``\texttt{gallier}'', ``\texttt{stark}'',
``\texttt{maechtig}'', ``\texttt{kaiser}'', ``\texttt{roemer}'' und ``\texttt{spinnt}''
Prädikats--Zeichen.
Als einzige Variable taucht in dem obigen Beispiel ``\texttt{X}'' auf.  Die
Funktions--Zeichen sind 
``\texttt{asterix}'', ``\texttt{obelix}'' und ``\texttt{caesar}''.
Alle diese Funktions--Zeichen sind 0--stellig.
Wenn wir die obigen Prolog--Klauseln in die Umgangssprache übersetzen, erhalten wir:
\begin{enumerate}
\item Asterix ist ein Gallier.
\item Obelix ist ein Gallier.
\item Gallier sind stark.
\item Wer stark ist, ist mächtig.
\item Wer Kaiser ist, ist mächtig.
\item Cäsar ist ein Kaiser.
\item Cäsar ist ein Römer.
\item Die Römer spinnen. 
\end{enumerate}
Das Ziel könnten wir in dem Fall als die Frage interpretieren, ob es jemanden gibt, der
mächtig ist und spinnt.

Die Grundidee beim logischen Programmieren ist es, dass ein Problem durch logische Formeln
beschrieben wird.  Die Lösung des Problems ist dann die Aufgabe einer geeigneten
\emph{Inferenz--Maschine}.  Das Ziel ist es also, dass der Programmierer nicht mehr
beschreiben muss, wie das Problem im Detail zu lösen ist, sondern nur noch eine präzise
Beschreibung des Problems abliefert.  Der Rest wird dann von der Maschine erledigt.
Die Sprache Prolog realisiert diese Grundidee teilweise.  Um das zu demonstrieren, geben
wir die oben angegebenen Programm--Klauseln in eine Datei ein, die wir
``\texttt{gallier.pl}'' nennen.  Dann starten wir den Prolog Interpreter mit dem Befehl
``\texttt{pl}''.  Wir werden mit einem Prompt der folgenden Form begrüßt:
\begin{verbatim}
    stroetma@stroetmannpc:~/Kurse/Informatik-I/Prolog> pl
    Welcome to SWI-Prolog (Version 5.0.8)
    Copyright (c) 1990-2002 University of Amsterdam.
    SWI-Prolog comes with ABSOLUTELY NO WARRANTY. This is free software,
    and you are welcome to redistribute it under certain conditions.
    Please visit http://www.swi-prolog.org for details.

    For help, use ?- help(Topic). or ?- apropos(Word).

    1 ?- 
\end{verbatim}
Die Zeichenfolge ``\texttt{?-}'' ist der Prolog--Prompt.  Hier geben wir  \\[0.1cm]
\hspace*{1.3cm} \texttt{consult(gallier).} \\[0.1cm]
ein (und zwar mit dem Punkt) und drücken \fbox{\textsl{Return}}. Damit fordern wir das Prolog--System auf, die
Programm--Klauseln aus der Datei ``\texttt{gallier.pl}'' zu laden.  Als Ergebnis erhalten
wir die Meldung
\begin{verbatim}
    1 ?- consult(gallier).
    % gallier compiled 0.00 sec, 1,712 bytes

    Yes
    2 ?- 
\end{verbatim}
Dies sagt aus, dass die Programm--Klauseln aus der Datei ``\texttt{gallier}'' erfolgreich
geladen wurden. Wir können nun unser Ziel eingeben und die \fbox{\textsl{Return}} Taste drücken.
Der Bildschirm sieht dann so aus:
\begin{verbatim}
    2 ?- maechtig(X), spinnt(X).

    X = caesar 

    Yes
\end{verbatim}
Das Prolog--System hat also  für die Variable
``\texttt{X}'' die Instantiierung $[ \mathtt{X} \mapsto \mathtt{caesar} ]$
gefunden, und  für diese Instantiierung folgt die Formel \\[0.1cm]
\hspace*{1.3cm} \texttt{maechtig(X) $\wedge$ spinnt(X)} \\[0.1cm]
aus den gegebenen Programm--Klauseln.
Um nun einen neuen Prompt zu erhalten, müssen  wir die \fbox{\textsl{Return}} Taste erneut  drücken.

In Prolog wird viel mit Listen gearbeitet.  Listen werden in Prolog mit dem
2--stelligen Funktions--Zeichen ``\texttt{.}'' konstruiert.  Ein Term der Form \\[0.1cm]
\hspace*{1.3cm} \texttt{.($s$,$t$)} \\[0.1cm]
steht also für eine Liste, die als erstes Element ``$s$'' enthält. ``$t$'' bezeichnet den
Rest der Liste.
Das Funktions--Zeichen ``\texttt{[]}'' steht
für die leere Liste. Eine Liste, die aus  den drei Elementen 
``\texttt{a}'', ``\texttt{b}'' und ``\texttt{c}'' besteht, kann also wie folgt dargestellt
werden: \\[0.1cm]
\hspace*{1.3cm} \texttt{.(a, .(b, .(c, [])))} \\[0.1cm]
Da dies relativ schwer zu lesen ist, darf diese Liste auch als \\[0.1cm]
\hspace*{1.3cm} \texttt{[a,b,c]} \\[0.1cm]
geschrieben werden.  Zusätzlich kann der Term ``\texttt{.($s$,$t$)}'' in der Form \\[0.1cm]
\hspace*{1.3cm} \texttt{[ $s$ | $t$ ]} \\[0.1cm]
geschrieben werden.  Um diese Kurzschreibweise zu erläutern, geben wir ein kurzes
Prolog--Programm an, dass zwei Listen aneinander hängen kann.  
Das Programm implementiert eine dreistelliges Prädikats \texttt{concat}.  Die Intention ist,
dass $\mathtt{concat}(l_1,l_2,l_3)$ für drei Listen $l_1$, $l_2$ und $l_3$ genau dann
wahr sein soll,
wenn die Liste $l_3$ dadurch entsteht, dass die Liste $l_2$ hinten an die Liste $l_1$
angehängt wird.  Das Programm besteht aus den folgenden beiden Klauseln:
\begin{verbatim}
  concat( [], L, L ).
  concat( [ X | L1 ], L2, [ X | L3 ] ) :- concat( L1, L2, L3 ).
\end{verbatim}
Wir können diese beiden Klauseln folgendermaßen in die Umgangssprache übersetzen:
\begin{enumerate}
\item Hängen wir eine Liste \texttt{L} an die leere Liste an, so ist das Ergebnis \texttt{L}.
\item Um an eine Liste \texttt{[ X | L1 ]}, die aus dem Element \texttt{X} und dem Rest \texttt{L1} besteht,
      eine Liste \texttt{L2} anzuhängen, hängen wir zunächst an die Liste \texttt{L1} die 
      Liste \texttt{L2} an und nennen das Ergebnis \texttt{L3}.  
      Das gesuchte Ergebnis ist dann die Liste \texttt{[ X | L3 ]}.
\end{enumerate}
Wir testen unser Programm gleich mal.  Wir nehmen an, dass die beiden Programm--Klauseln in der Datei
``\texttt{concat.pl}'' abgespeichert sind und dass wir diese Datei mit ``\texttt{consult}'' geladen haben.
Dann betrachten wir das Ziel \\[0.1cm]
\hspace*{1.3cm} \texttt{concat( [ 1, 2, 3 ], [ a, b, c ], L ).} \\[0.1cm]
Geben wir dieses Ziel als Anfrage an das Prolog--System, so erhalten wir die Antwort:
\begin{verbatim}
    3 ?- concat([1,2,3], [a,b,c], L).

    L = [1, 2, 3, a, b, c] 
\end{verbatim}
Die obige Interpretation des gegebenen Prolog--Programms ist \emph{funktional}, dass heißt 
wir fassen die ersten beiden Argumente des Prädikats \texttt{concat} als Eingaben auf und 
interpretieren das letzte Argument als Ausgabe.  Diese Interpretation ist ist aber keineswegs die 
einzig mögliche Interpretation.  Um das zu sehen, geben wir als Ziel \\[0.1cm]
\hspace*{1.3cm} \texttt{concat(L1, L2, [1,2,3]).} \\[0.1cm]
ein und drücken, nachdem das System uns die erste Antwort gegeben hat, nicht die Taste 
\fbox{\textsl{Return}} sondern die Taste \fbox{\texttt{;}}.  Wir erhalten:
\begin{verbatim}
    6 ?- concat(L1, L2, [1, 2, 3]).

    L1 = []
    L2 = [1, 2, 3] ;

    L1 = [1]
    L2 = [2, 3] ;

    L1 = [1, 2]
    L2 = [3] ;

    L1 = [1, 2, 3]
    L2 = [] ;

    No
\end{verbatim}
In diesem Fall hat das Prolog--System nacheinander alle Möglichkeiten berechnet, die 
Liste ``\texttt{[1, 2, 3]}'' in zwei Listen zu zerlegen!

\section{Prolog --- Wie funktioniert es}
Prolog kann aufgefasst werden als eine Implementierung der Relation
$\leadsto_\mathcal{P}^*$, die wir am Anfang dieses Abschnittes vorgestellt haben.  Bei der
Implementierung dieser Relation ist allerdings noch ein Problem zu lösen.
Betrachten wir die folgende Situation:
\begin{enumerate}
\item $\langle A_1 \wedge \cdots \wedge A_m, \sigma \rangle$ ist ein instantiiertes Ziel.
\item $\mathcal{P}$ ist ein logisches Programm,
\item $H_1 \leftarrow B^{(1)}_1 \wedge \cdots \wedge B^{(1)}_{n(1)}$ und
      $H_2 \leftarrow B^{(2)}_1 \wedge \cdots \wedge B^{(2)}_{n(2)}$ 
      sind zwei   Programm--Klauseln aus $\mathcal{P}$.
\item Die syntaktischen Gleichungen $A_1 \doteq H_1$ und
      Gleichung $A_1 \doteq H_2$ sind beide lösbar und für $i=1,2$ sei $\mu_i = \textsl{mgu}(A_1, H_i)$.
\item Weiter sei $\tau_i = \mu_i \restriction \FV(A_1)$ für $i=1,2$.
\end{enumerate}
In diesem Fall kann das Ziel  $\langle A_1 \wedge \cdots \wedge A_m, \sigma \rangle$ auf
zwei verschiedene Arten reduziert werden, es gilt dann sowohl
\begin{enumerate}
\item $\big\langle A_1 \wedge \cdots \wedge A_m, \sigma \big\rangle \leadsto_\mathcal{P} \big\langle B^{(1)}_1\mu \wedge \cdots \wedge B^{(1)}_{n(1)}\mu \wedge A_2 \wedge \cdots  \wedge A_m, \sigma\tau_1 \big\rangle$ 

      als auch
\item $\big\langle A_1 \wedge \cdots \wedge A_m, \sigma \big\rangle \leadsto_\mathcal{P} \big\langle B^{(2)}_1\mu \wedge \cdots \wedge B^{(2)}_{n(2)}\mu \wedge A_2 \wedge \cdots \wedge A_m, \sigma\tau_2 \big\rangle$ .
\end{enumerate}
An dieser Stelle muss der Prolog--Interpreter sich für eine der beiden Möglichkeiten
entscheiden.  In Ermangelung tieferer Einsichten welche Möglichkeit zum Ziel führt
orientiert sich der Prolog--Interpreter daher an der Reihenfolge, in der die
Programm--Klauseln in dem Programm $\mathcal{P}$ auftreten: Ist 
$H_1 \leftarrow B^{(1)}_1 \wedge \cdots \wedge B^{(1)}_{n(1)}$ die erste Klausel, so wird
 zunächst die erste der beiden oben angegebenen Reduktionen versucht.
 Falls allerdings im Anschluss daran die Reduktion des Zieles
$\big\langle B^{(1)}_1\mu \wedge \cdots \wedge B^{(1)}_{n(1)}\mu \wedge A_2 \wedge \cdots  \wedge A_m, \sigma\tau_1 \big\rangle$
 nach endlich vielen Schritten \emph{scheitert}, so werden systematisch alle
verbleibenden Möglichkeiten durchpropiert.

An dieser Stelle müssen wir noch festlegen, was wir unter dem Scheitern eines Zieles
verstehen wollen.  Dazu dient die folgende Definition.

\begin{Definition}[Unmittelbares Scheitern]
{\em
    Ein Ziel $G_1$ \emph{scheitert unmittelbar} \\
    (bezüglich eines Programmes $\mathcal{P}$) wenn es kein Ziel
    $G_2$ gibt, so dass gilt: \\[0.1cm]
    \hspace*{1.3cm} $G_1 \leadsto_\mathcal{P} G_2$ 
}  \hspace*{\fill} $\Box$
\end{Definition}
Betrachten wir die Definition der Relation $\leadsto_\mathcal{P}$, so stellen wir fest
dass ein Ziel $G = \langle A_1 \wedge \cdots \wedge A_n, \sigma \rangle$ genau dann
unmittelbar scheitert, wenn es keine Programm--Klausel \\[0.1cm]
\hspace*{1.3cm} $H \leftarrow B_1 \wedge \cdots \wedge B_m$ \\[0.1cm]
gibt, so dass die syntaktische Gleichung $A_1\sigma \doteq H$ (nach eventueller
Umbenennung der Variablen in $H$) lösbar ist.

Wir können jetzt die Frage beantworten, wie die Reduktions--Relation
$\leadsto_\mathcal{P}$ in Prolog realisiert wird:  Intern verwaltet Prolog eine Liste
$G\!L$ von Zielen.  Wird der Interpreter mit einem Ziel $G$ gestartet, so wird zunächst \\[0.1cm]
\hspace*{1.3cm} $G\!L = \big[ \langle G, [] \rangle \big]$ \\[0.1cm]
gesetzt, dass heißt die Ziel--Liste enthält am Anfang genau das instantiierte Ziel $\langle G, [] \rangle$.  Dann läuft der
folgende Algorithmus ab:
\begin{enumerate}
\item Überprüfe, ob die Ziel--Liste $G\!L$ leer ist. 
      Falls ja, dann ist die Reduktion des Ziels $G$ endgültig gescheitert.
      Sonst gehe zum  Schritt 2.
\item Die Ziel--Liste kann jetzt nicht leer sein, sie hat also die Form \\[0.1cm]
      \hspace*{1.3cm} $G\!L = [ Z | Zs ]$ \\[0.1cm]
      Wir führen dann die folgende Fallunterscheidung durch:
      \begin{enumerate}
      \item $Z$ hat die Form $Z = \langle \verum, \tau \rangle$.

            In diesem Fall hat der Prolog--Interpreter die ihm gestellte Aufgabe gelöst und
            gibt die Substitution $\tau$ als Ergebnis aus.
      \item Andernfalls werden alle mögliche Reduktionen des Ziels $Z$ durchgeführt.  Falls \\[0.1cm]
            \hspace*{1.3cm} $Z \leadsto_\mathcal{P} Z_i$  für $i=1,\cdots,n$ \\[0.1cm]
            gilt,  ändern wir $G\!L$ wie folgt ab: \\[0.1cm]
            \hspace*{1.3cm} $G\!L := [ Z_1, \cdots, Z_n | Zs ]$. \\[0.1cm]
            Die Ziele $Z_i$ werden hier in der  Reihenfolge in die Ziel--Liste $G\!L$ eingefügt, die der
            Reihenfolge der Programm--Klauseln entspricht, mit der die Reduktionen 
            $Z \leadsto_\mathcal{P} Z_i$
            durchgeführt worden sind.

            Im Anschluss daran gehen wir wieder zu Schritt 1.
      \end{enumerate}
\end{enumerate}
Bei dem obigen Algorithmus ist zu beachten, dass im Schritt 2.(b) durchaus der Fall $n=0$
auftreten kann.  Dieser Fall liegt dann vor, wenn das Ziel $Z$ unmittelbar scheitert.  Der Effekt von
dem Schritt 2.(b) besteht in diesem Fall darin, dass das Ziel $Z$ einfach aus der Liste $G\!L$
entfernt wird.  Falls das Ziel $Z$ nicht unmittelbar scheitert, so wird es durch alle
Ziele ersetzt, auf die es reduziert werden kann.  Wir definieren nun:
\begin{Definition}[Scheitern]
{\em
    Ein Ziel $G$ \emph{scheitert}, wenn der obige Algorithmus im Schritt 1 beendet wird, weil die 
    Ziel--Liste $G\!L$ leer ist.
\hspace*{\fill} $\Box$
}
\end{Definition}

Im Kontext von Prolog wird ein Ziel $G$  oft auch als \emph{Anfrage} bezeichnet. 
Das ist der Grund für die folgende Sprechweise:
\begin{Definition}[Berechnete Antwort]
{\em
  Falls der oben dargestellte Algorithmus im Schritt 2.(a) beendet wird, dann gilt für das gegebene Ziel
  $G$ \\[0.1cm]
  \hspace*{1.3cm} $\langle G, [] \rangle \leadsto_\mathcal{P}^* \langle \verum, \tau \rangle$. \\[0.1cm]
  In diesem Fall nennen wir $\tau$ die \emph{berechnete Antwort}. 
} \hspace*{\fill} $\Box$
\end{Definition}

Der oben dargestellte Algorithmus erweckt den Anschein, als ob er systematisch alle
Möglichkeiten ein Ziel zu reduzieren durchprobiert.  Wenn es also überhaupt eine
Möglichkeit gibt, ein Ziel zu \emph{lösen}, dass heißt auf ein Ziel der Form 
 $\langle \verum, \tau \rangle$ zu reduzieren, dann sollte diese Möglichkeit auch gefunden
 werden.  Leider ist dies ein Trugschluss.  Der Grund ist, dass die Reduktions--Relation
$\leadsto_\mathcal{P}$ nicht terminieren muss, es kann durchaus sein, dass es für ein
gegebenes instantiiertes Ziel $Z$ eine unendliche Folge $(Z_n)_{n\in \mathbb{N}}$ von instantiierten Zielen gibt, so
dass gilt:
\begin{enumerate}
\item $Z \leadsto_\mathcal{P} Z_0$
\item $Z_n \leadsto_\mathcal{P} Z_{n+1}$ \quad für alle $n\in\mathbb{N}$.
\end{enumerate}
Falls nun auch $Z \leadsto_\mathcal{P} H \leadsto_\mathcal{P}^* \langle \verum, \tau \rangle$ gilt, 
das Ziel $Z$ also grundsätzlich lösbar wäre, so wird der obige Algorithmus diese Lösung
dann nicht finden, wenn er zuerst die Reduktion $Z \leadsto_\mathcal{P} Z_0$ versucht, denn
dann wird er in einer Endlos--Schleife stecken bleiben.  Das folgende Programm illustriert
diesen Effekt:
\begin{verbatim}
  loop :- loop.
  loop.
\end{verbatim}
Wird dieses Programm geladen und wird anschließend versucht, das Ziel \texttt{loop} zu
lösen, so liefert der Prolog--Interpreter die Meldung
\begin{verbatim}
  ERROR: Out of local stack
\end{verbatim}
Der Stack, der da übergelaufen ist, ist übrigens genau die Liste der Ziele $G\!L$, die als Stack
implementiert ist.

In manchen Fällen kann  das Problem der Nicht--Terminierung der Relation
$\leadsto_\mathcal{P}$ durch eine Umordnung der Programm--Klauseln umgangen werden.
Hätten wir das obige Programm in  der Form
\begin{verbatim}
  loop.
  loop :- loop.
\end{verbatim}
eingegeben, so wäre das Problem der Endlos--Schleife nicht aufgetreten.  Leider gibt es bei
komplexeren Programmen oft keine Anordnung der Klauseln, die das Problem der
Endlos--Schleifen löst.  

Die handelsüblichen Prolog--Interpreter haben noch ein weiteres Problem: Die Unifikation,
das heißt der Algorithmus zum Lösen syntaktischer Gleichungen, ist (aus Effizienzgründen)
nicht korrekt implementiert.  Wir erinnern noch einmal an die Regeln zur Reduktion
syntaktischer Gleichungen.  Die erste dieser Regeln lautete:
\begin{enumerate}
\item Falls $y\in\mathcal{V}$ eine Variable ist, \fbox{die nicht in dem Term $t$ auftritt}, so
      können wir die folgende Reduktion durchführen: \\[0.1cm]
      \hspace*{2.1cm} $\Big\langle E \cup \big\{ y \doteq t \big\}, \sigma \Big\rangle \quad\leadsto\quad \Big\langle E[y \mapsto t], \sigma\big[ y \mapsto t \big] \Big\rangle$.
\end{enumerate}
In den handelsüblichen Prolog--Interpretern ist statt dieser Regel die folgende Regel
implementiert:
\begin{enumerate}
\item[$1'$.] Falls $y\in\mathcal{V}$ eine Variable ist, so
      können wir die folgende Reduktion durchführen: \\[0.1cm]
      \hspace*{2.1cm} $\Big\langle E \cup \big\{ y \doteq t \big\}, \sigma \Big\rangle \quad\leadsto\quad \Big\langle E[y \mapsto t], \sigma\big[ y \mapsto t \big] \Big\rangle$.
\end{enumerate}
Was hier fehlt ist der Test \fbox{\em die nicht in dem Term $t$ auftritt}.  Dieser Test
wird als \emph{Occur--Check} bezeichnet.  Mit der modifizierten Regel können wir eine
Reduktion der Form
\\[0.1cm]
\hspace*{1.3cm} $\langle \{ x = f(x) \}, [] \rangle \;\leadsto\; \langle \emptyset, [ x \mapsto f(x) ] \rangle$ \\[0.1cm]
durchführen.  Dies liefert aber ein falsches Ergebnis, denn offensichtlich ist die Substitution 
$[x \mapsto f(x)]$ keine Lösung der syntaktischen Gleichung $x \doteq f(x)$.  
Bei Prolog bleibt es dem Programmierer überlassen sicherzustellen, dass dergleichen nicht 
passiert.

\section{Funktionales Programmieren in Prolog}
Im letzten Abschnitt haben wir gesehen, dass die Unifikation in Prolog nicht korrekt implementiert ist,
denn der Occur--Check wird bei der Unifikation nicht durchgeführt.  Dadurch ist aber der Satz \ref{satz:prolog-korrekt}
nicht länger gültig, es kann passieren, dass für ein Ziel $G$ folgendes gilt: \\[0.1cm]
\hspace*{1.3cm} $\langle G, [] \rangle \leadsto_\mathcal{P}^* \langle \verum, \tau \rangle \; \not\Rightarrow \; \mathcal{P} \models G\tau$ \\[0.1cm]
Ein  Programm $\mathcal{P}$, wo dieser Fall tatsächlich auftritt, ist durch die beiden folgenden Klausel gegeben: 
\begin{verbatim}
      bug :- equal(X, s(X)).
      equal(X,X).
\end{verbatim}
Betrachten wir das Ziel \texttt{bug}, so liefert Prolog hier die Antwort ``\texttt{yes}'', obwohl \\[0.1cm]
\hspace*{1.3cm} $\mathcal{P} \not\models \mathtt{bug}$ \\[0.1cm]
gilt.  Wie können wir verhindern,  dass Prolog falsche Antworten liefert?
Eine Möglichkeit besteht darin, den Gebrauch der Unifikation einschzuschränken.  
Die Gundidee ist die folgende:  Ist eine syntaktische Gleichung \\[0.1cm]
\hspace*{1.3cm} $s \doteq t$ \\[0.1cm]
gegeben, so wird der Occur--Check sicher nicht gebraucht, wenn eine der beiden Seiten dieser Gleichung
gar keine Variablen enthält!  Die Forderung ist also, dass bei allen syntaktischen Gleichungen $s \doteq t$
die wir im Verlaufe einer Rechnung erhalten, immer \\[-0.2cm]
\hspace*{1.3cm} $\textsl{var}(s) = \emptyset$ oder $\textsl{var}(t) = \emptyset$ \\[0.1cm]
gilt.  Um diese Forderung sicherzustellen, wollen wir die Argumente von Prädikaten in \emph{Eingabe--Argumente} und 
\emph{Ausgabe--Argumente} unterteilen.  Die Idee ist, dass Eingabe--Argumente beim Aufruf eines Prädikats keine
Variablen enthalten dürfen.  Ist dann die Abarbeitung des Prädikats durch Prolog erfolgreich, so sind danach auch
die Variablen der Ausgabe--Argumente durch die berechnete Antwort so instantiiert, dass sie keine Variablen
mehr enthalten.

Diese Methode, Prolog--Programme zu erstellen, ist eng verwandt mit dem Paradigma des \emph{funktionalen Programmierens}
und die so erstellten Programme wollen wir, in Ermangelung eines besseren Namens, daher als \emph{funktionale} Programme
bezeichnen.  

Um, wie oben angekündigt, die Argumente eines Prädikats in Eingabe--Argumente und Ausgabe--Argumente
unterteilen zu können, werden wir versuchen, Prädikate als
Funktionen zu interpretieren.  Was damit gemeint ist, sehen wir am besten anhand von
Beispielen.  Wir hatten im vorletzten Abschnitt Klauseln zur Implementierung des dreistelligen
Prädikats \texttt{concat}
angegeben.  Wir wiederholen diese Klauseln hier.
\begin{verbatim}
  concat( [], L, L ).
  concat( [ X | L1 ], L2, [ X | L3 ] ) :- 
      concat( L1, L2, L3 ).
\end{verbatim}
Das Prädikat \texttt{concat} besitzt die folgende Eigenschaft:  Hat ein Ziel $G$ die Form\\[0.1cm]
\hspace*{1.3cm} $\texttt{concat}(l_1,l_2, \texttt{X})$ \\[0.1cm]
und sind die Terme $l_1$ und $l_2$ Listen, die keine Variablen enthalten, so ist der
Aufruf von $G$ immer erfolgreich und die berechnete Antwort substituiert die Variable
\texttt{X} durch $l_1 * l_2$.  Hier bezeichnen wir mit $l_1 * l_2$ die Konkatenation der
Listen $l_1$ und $l_2$.  Wir können also sagen, dass das Prädikat \texttt{concat} die
Funktion \\[0.1cm]
\hspace*{1.3cm} $*: \textsl{List} \times \textsl{List} \rightarrow \textsl{List}$ \\[0.1cm]
implementiert.  Um allgemein festlegen zu können, was wir unter einem funktionalen
Prolog--Programm verstehen wollen, werden wir den Begriff der
\emph{Eingabe/Ausgabe--Spezifikation} einführen.  Zuvor brauchen wir aber noch die folgende Definition.

\begin{Definition}[Geschlossener Term]
{\em
   Wir bezeichnen einen Term $t$ als \emph{geschlossen}, wenn er keine Variablen enthält, wenn also 
   $\textsl{var}(t) = \emptyset$ gilt.   Analog nennen wir ein Ziel $G$
    \emph{geschlossen}, wenn $\FV(G) = \emptyset$ gilt.
   \hspace*{\fill} $\Box$
}
\end{Definition}
Beispielsweise ist der Term $[1,2,3]$ eine geschlossener Term, während  der Term $[1,\mathtt{X},7]$ nicht geschlossen ist, denn er
enthält die Variable $\mathtt{X}$.

Bei den kommenden Definitionen ist es bequem, die folgende Sprechweise zu benutzen:
Falls $G$ ein Ziel ist, so dass $\langle G, [] \rangle \leadsto_\mathcal{P}^* \langle \verum, \tau \rangle$ gilt, 
so sagen wir, dass eine \emph{Berechnung} des Ziels $G$ die in $G$ auftretenden Variablen  mit der Substitution 
$\tau$ \emph{instantiiert}.  Außerdem bezeichnen wir die Instantiierung $G\tau$ als \emph{Lösung} des Ziels $G$.

\begin{Definition}[E/A--Spezifikation] \hspace*{\fill} \\
{\em
    Es sei $p$ ein $n$--stelliges Prädikats--Zeichen.  Eine
    \emph{Eingabe/Ausgabe--Spezifikation} (oder kürzer E/A--Spezifikation)
     für $p$ ist ein $n$--Tupel der Form \\[0.1cm]
    \hspace*{1.3cm} $\langle E\!A_1, \cdots, E\!A_n \rangle$ \quad     mit $E\!A_i \in \{ \mathquote{+}, \mathquote{-} \}$.  \\[0.1cm]
    Ist $\langle E\!A_1, \cdots, E\!A_n \rangle$ eine E/A--Spezifikation für
    das Prädikats--Zeichen $p$, so schreiben wir auch \\[0.1cm]
    \hspace*{1.3cm} $p( E\!A_1, \cdots, E\!A_n )$. \\[0.1cm]
    Ist $E\!A_i = \mathquote{+}$, so sagen wir, dass das $i$--te Argument von $p$ ein
    \emph{Eingabe--Argument} ist, und ansonsten, wenn also  $E\!A_i = \mathquote{-}$ gilt,
    bezeichnen wir das $i$--te Argument als \emph{Ausgabe--Argument}. 

    Ein Ziel $p(s_1, \cdots, s_m)$ \emph{genügt} einer E/A--Spezifikation
    für $p$ falls jedes Eingabe--Ar\-gu\-ment ein geschlossener Term ist.
 \hspace*{\fill} $\Box$
}   
\end{Definition}


Eine E/A--Spezifikation für \texttt{concat} ist beispielsweise \\[0.1cm]
\hspace*{1.3cm} $\mathtt{concat}(+,+,-)$. \\[0.1cm]
Das Ziel $p([1,2],[3],X)$ genügt dieser E/A--Spezifikation, während das Ziel
$p(X,[],Y)$ dieser E/A--Spezifikation nicht genügt, denn das erste Argument
ist ein Eingabe--Argument, enthält aber die Variable \texttt{X}.
Eine andere E/A--Spezifikation für \texttt{concat} ist \\
\hspace*{1.3cm} $\mathtt{concat}(-,+,-)$. \\[0.1cm]
Das Ziel $p(X,[],Y)$ genügt dieser E/A--Spezifikation.
Allerdings ist diese E/A--Spezifikation für  $\mathtt{concat}$ in einem
intuitiven Sinne falsch, während die zuerst gegebene E/A--Spezifikation
$\mathtt{concat}(+,+,-)$ richtig ist.  Was wir hier unter richtig und falsch verstehen,
präzisieren wir in der nächsten Definition.

\begin{Definition}[Korrektheit einer E/A--Spezifikation] 
{\em
    Es sei
    \begin{enumerate}
    \item  $\mathcal{P}$ ein Prolog--Programm,
    \item  $p$  ein $n$--stelliges Prädikats--Zeichen und
    \item  $\sigma$ eine  E/A--Spezifikation für $p$.
    \end{enumerate}
    Dann nennen wir $\sigma$ \emph{korrekt bezüglich} $\mathcal{P}$ falls gilt: 
    \begin{enumerate}
    \item Ist $G$ ein Ziel, das $\sigma$ genügt, und
    \item ist $G\tau$ eine Lösung von $G$,
    \end{enumerate}
    dann ist $G\tau$ geschlossen.
     \hspace*{\fill} $\Box$
} 
\end{Definition}

Die E/A--Spezifikation $\mathtt{concat}(+,+,-)$ ist korrekt bezüglich des oben
angegeben Prolog--Programms, denn 
 für ein Ziel der Form $G = \texttt{concat}(l_1,l_2,L)$ mit geschlossenen
Termen $l_1$ und $l_2$ instantiiert eine Lösung die Variable \texttt{L} mit dem Term 
$l_1 * l_2$ und dieser Term ist geschlossen.
 Umgekehrt ist die E/A--Spezifikation
$\mathtt{concat}(-,+,-)$
bezüglich des oben angegeben Prolog--Programms nicht korrekt,  denn das Ziel
$G = p(\mathtt{L1},[],\mathtt{L3})$ genügt dieser Spezifikation, aber es hat die Lösung  \\[0.1cm]
\hspace*{1.3cm} $\mathtt{concat}(\mathtt{[X]},[],\mathtt{[X]})$, \\[0.1cm]
die offenbar nicht geschlossen ist.

Um nachzuweisen, dass eine E/A--Spezifikation nicht korrekt ist, reicht es aus
ein Ziel $G$ anzugeben, dass der Spezifikation genügt und dann zu zeigen,
dass es für $G$ eine Lösung gibt, die nicht geschlossen ist.
Aber wie weisen wir nach dass eine E/A--Spezifikation korrekt ist?
Warum ist beispielsweise die E/A--Spezifikation $\mathtt{concat}(+,+,-)$
korrekt?  Um dies zu sehen, betrachten wir die beiden Klauseln des \texttt{concat}
implementierenden Prolog--Programms.  Die erste Klausel ist \\[0.1cm]
\hspace*{1.3cm} $\mathtt{concat}(\mathtt{[]}, \mathtt{L}, \mathtt{L})$. \\[0.1cm]
Wir betrachten was passiert, wenn ein Ziel $\mathtt{concat}(l_1,l_2,t)$, das der obigen
E/A--Spezifikation genügt, mit dieser Klausel reduziert wird.  Dann wird zunächst die
syntaktische Gleichung \\[0.1cm]
\hspace*{1.3cm} $\mathtt{concat}(l_1,l_2,t) \doteq \mathtt{concat}(\mathtt{[]}, \mathtt{L}, \mathtt{L})$. \\[0.1cm]
gelöst.  Dabei wird  die Variable \texttt{L} mit $l_2$ instantiiert. Da $l_2$ geschlossen
ist, und \texttt{L} die einzige Variable ist, die in dem Ziel vorkommt, kann nichts mehr
schiefgehen: alle Variablen des Ziels sind an geschlossene Terme gebunden.

Betrachten wir nun die zweite Klausel \\[0.1cm]
\hspace*{1.3cm} {\tt concat( [ X | L1 ], L2, [ X | L3 ] ) :- concat( L1, L2, L3 ).} \\[0.1cm]
Wird ein Ziel  $\mathtt{concat}(l_1,l_2,t)$, das der obigen
E/A--Spezifikation genügt, mit dieser Klausel reduziert, so wird zunächst die syntaktische
Gleichung \\[0.1cm]
\hspace*{1.3cm} $\mathtt{concat}(l_1,l_2,t) \doteq \mathtt{concat( [ X | L1 ], L2, [ X | L3 ] )}$ \\[0.1cm]
gelöst.  Da die Terme $l_1$ und $l_2$ geschlossen sind, werden dabei die Variablen 
\texttt{X}, \texttt{L1} und \texttt{L2} mit geschlossen Termen instantiiert.  Das Ziel \\[0.1cm]
\hspace*{1.3cm} $\langle \mathtt{concat}(l_1,l_2,t), [] \rangle$ \\[0.1cm]
wird dann reduziert zu \\[0.1cm]
\hspace*{1.3cm} $\langle \mathtt{concat( L1\mu, L2\mu, L3\mu )}, \tau \rangle$, \\[0.1cm]
wobei $\mu = \textsl{mgu}\big(\mathtt{concat}(l_1,l_2,t),\,\mathtt{concat( [ X | L1 ], L2, [ X | L3 ] )}\big)$ 
gilt.  Folglich sind die Terme $\mathtt{X}\mu$, $\mathtt{L1}\mu$ und $\texttt{L2}\mu$ geschlossen.  Daher 
genügt das neue Ziel $\mathtt{concat( L1\mu, L2\mu, L3\mu )}$ der E/A--Spezifikation für \texttt{concat}.
Falls nun dieses Ziel gelöst wird, so wissen wir, dass 
dabei der Term $\texttt{L3}\mu$ so instantiiert wird, dass er danach geschlossen ist.  
Dann ist aber auch der Term $\texttt{[X|L3]}\mu$ geschlossen
und das war zu zeigen.

Wir versuchen nun, die Überlegungen, die wir gerade am Beispiel des Prädikats \texttt{concat} vorgeführt haben,
zu verallgemeinern.  Zu diesem Zwecke definieren wir für ein gegebenes Ziel $G$ zunächst die Menge der Eingabe--Variable
$\FV^+(G)$ und die Menge der Ausgabe--Variablen $\FV^-(G)$.

\begin{Definition}[$\FV^+(G)$, $\FV^-(G)$]
{\em
    Es sei $G = p(s_1,\cdots,s_n)$ ein Ziel und für das Prädikats--Zeichen $p$ sei $p(E\!A_1,\cdots,E\!A_n)$ mit $E\!A_i \in \{ \mathquote{+}, \mathquote{-} \}$ 
    eine E/A--Spezifikation . Dann definieren wir die Menge der \emph{Eingabe--Variablen}
    $\FV^+(G)$ als die Vereinigung der Variablen--Mengen, die in den Eingabe--Argumenten von $G$ auftreten: \\[0.1cm]
    \hspace*{1.3cm} $\FV^+(G) = \bigcup \big\{ \textsl{var}(s_i) \;|\; E\!A_i = \mathquote{+} \}$. \\[0.1cm]
    Analog ist die Menge der \emph{Ausgabe--Variablen} als die Vereinigung der Variablen--Mengen, 
    die in den Ausgabe--Variablen von $G$ auftreten, definiert: \\[0.1cm]
    \hspace*{1.3cm} $\FV^-(G) = \bigcup \big\{ \textsl{var}(s_i) \;|\; E\!A_i = \mathquote{-} \}$. 
    \hspace*{\fill} $\Box$
}
\end{Definition}

\noindent
\textbf{Bemerkung}: Die obige Definition benutzt eine Notation aus der Mengenlehre, die 
Ihnen vielleicht noch nicht geläufig ist.  Ist $M$ eine Menge, die als Elemente wieder Mengen enthält, 
so  $\bigcup M$ als die Menge definiert, die alle Objekte enthält, die Element einer Menge $m\in M$ sind: \\[0.1cm]
\hspace*{1.3cm} $\bigcup M := \{ x \,|\; \exists m \!\in\! M : x \!\in\! m \}$ \\[0.1cm]
\textbf{Beispiel}:  Es gilt \\[0.1cm]
\hspace*{1.3cm} $\bigcup \big\{ \{1,2,3\}, \{3,4,5\}, \{7\} \big\} = \{ 1,2,3,4,5,7\}$. \\[0.1cm]
Allgemein gilt für eine endliche Menge $M = \{ m_1 , \cdots, m_n \}$ \\[0.1cm]
\hspace*{1.3cm} $\bigcup \{ m_1 , \cdots, m_n \} = m_1 \cup \cdots \cup m_n$
\vspace{0.3cm}

\noindent
\textbf{Beispiel}:  Wir geben nun ein Beispiel für die Berechnung von Eingabe--Variablen und Ausgabe--Variablen.
Wir betrachten wieder das Prädikats--Zeichen $\mathtt{concat}$ mit der E/A--Spezifikation 
$\mathtt{concat}(+,+,-)$.  Für das Ziel $G = \mathtt{concat}( [ \mathtt{X} | \mathtt{Xs} ], [1], [ \mathtt{Y} | \mathtt{Ys} ] )$ gilt dann \\[0.1cm]
\hspace*{1.3cm} $\FV^+(G) = \textsl{var}([ \mathtt{X} | \mathtt{Xs} ]) \cup \textsl{var}([1]) = \{ \mathtt{X}, \mathtt{Xs} \} \cup \{\} = \{ \mathtt{X}, \mathtt{Xs} \}$ \quad und \\[0.1cm]
\hspace*{1.3cm} $\FV^-(G) = \textsl{var}([ \mathtt{Y} | \mathtt{Ys} ]) = \{ \mathtt{Y}, \mathtt{Ys} \}$. \\[0.1cm]
Damit haben wir nun alles Material zusammen, um definieren zu können, wann eine Programm--Klausel
mit gegebenen E/A--Spezifikationen verträglich ist.  Wir gehen im Rest dieses Abschnittes davon aus, dass
für jedes Prädikats--Zeichen eine E/A--Spezifikation gegeben ist.

\begin{Definition}[Verträglichkeit]
{\em
    Eine Programm--Klausel \\[0.1cm]
    \hspace*{1.3cm} $H \;\mathtt{:-}\; B_1\mathtt{,}\, \cdots\mathtt{,}\, B_n\mathtt{.}$ \\[0.1cm]
    ist mit den gegeben E/A--Spezifikationen \emph{verträglich}, wenn die folgenden Bedingungen erfüllt sind.
    \begin{enumerate}
    \item Für alle $i=1,\cdots,n$ gilt \\[0.1cm]
          \hspace*{1.3cm} $\FV^+(B_i) \subseteq \FV^+(H) \cup \FV^-(B_1) \cup \cdots \cup \FV^-(B_{i-1})$.
    \item Für den Kopf der Klausel gilt \\[0.1cm]
          \hspace*{1.3cm}  $\FV^-(H) \subseteq \FV^+(H) \cup \FV^-(B_1) \cup \cdots \cup \FV^-(B_{n})$. \hspace*{\fill} $\Box$
    \end{enumerate}
}
\end{Definition}

Es ist nicht schwer, die Definition der Verträglichkeit zu motivieren.  Wenn die obige Klausel
benutzt wird, um eine Antwort für ein Ziel $G$ zu berechnen, so wird $H$ mit $G$ unifiziert.
Falls das Ziel der E/A--Spezifikation genügt, ist die Menge der Eingabe--Variablen von $G$ leer.
Nach der Unifikation ist daher auch die Menge der Eingabe--Variablen von $H$ leer.  Das Ziel $G$ wird dann
durch das Ziel $B_1\mathtt{,}\, \cdots\mathtt{,}\, B_n$ ersetzt, wobei aber jetzt schon die Eingabe--Variablen
von $H$ mit geschlossenen Termen instantiiert worden sind.  Da \\[0.1cm]
\hspace*{1.3cm} $\FV^+(B_1) \subseteq \FV^+(H)$ \\[0.1cm]
gilt, sind dann auch die Eingabe--Variablen von $B_1$ mit geschlossenen Termen instantiiert.  
Ist irgendwann das Ziel $B_1$ gelöst, so sind danach auch die Ausgabe--Variablen von $B_1$ 
mit geschlossenen Termen instantiiert.  Da \\[0.1cm]
\hspace*{1.3cm} $\FV^+(B_2) \subseteq \FV^+(H) \cup \FV^-(B_1)$ \\[0.1cm]
ist bedingt dies, das nun das Ziel $B_2$ seiner E/A--Spezifikation genügt.  Fahren wir so fort,  so  können wir 
erkennen, dass alle  $B_i$ in dem Moment mit geschlossenen Termen instantiiert sind, in dem sie bei der Abarbeitung
an die Reihe kommen.  Sind schließlich alle $B_i$ abgearbeitet, so sind zum Schluss auch die Ausgabe--Variablen von
$H$ vollständig instantiiert, denn es gilt ja \\[0.1cm]
\hspace*{1.3cm}  $\FV^-(H) \subseteq \FV^+(H) \cup \FV^-(B_1) \cup \cdots \cup \FV^-(B_{n})$. \\[0.1cm]
Diese Argumentation legt den folgenden Satz nahe.

\begin{Satz} \label{vertraelich}
{\em
    Es sei $\mathcal{P}$ ein Prolog--Programm und alle Programm--Klauseln aus $\mathcal{P}$ seien mit 
    der gegeben E/A--Spezifikation verträglich.  Ist dann $G$ ein Ziel, das der gegebenen E/A--Spezifikation
    genügt und gilt \\[0.1cm]
    \hspace*{1.3cm} $\langle G, [] \rangle \leadsto_\mathcal{P}^* \langle \verum, \tau\rangle$, \\[0.1cm]
    so gilt $\FV(G\tau) = \emptyset$.  Außerdem genügen dann auch alle Ziele $G_i$, die bei dieser Rechnung abgearbeitet werden,
    ihrer E/A--Spezifikation.
    \hspace*{\fill} $\Box$
}
\end{Satz}

\noindent
\textbf{Beispiel}: Wir weisen nach, dass die oben für \texttt{concat} angegeben Klauseln der E/A--Spezifikation
$\texttt{concat}(+,+,-)$ genügen. Für die Klausel \\[0.1cm]
\hspace*{1.3cm} \texttt{concat([], L, L).} \\[0.1cm]
ist zu zeigen, dass \\[0.1cm]
\hspace*{1.3cm} $\FV^-\big(\mathtt{concat}(\mathtt{[]}, \mathtt{L}, \mathtt{L})\big) \subseteq \FV^+\big(\mathtt{concat}(\mathtt{[]}, \mathtt{L}, \mathtt{L})\big)$ \\[0.1cm]
gilt.  Das folgt sofort aus \\[0.1cm]
\hspace*{1.3cm}  $\FV^-\big(\mathtt{concat}(\mathtt{[]}, \mathtt{L}, \mathtt{L})\big) = \{ \mathtt{L} \}$ und $\FV^+\big(\mathtt{concat}(\mathtt{[]}, \mathtt{L}, \mathtt{L})\big)  = \{ \mathtt{L} \}$. \\[0.1cm]
Für die zweite Klausel \\[0.1cm]
\hspace*{1.3cm} \texttt{concat( [ X | L1 ], L2, [ X | L3 ] ) :- concat( L1, L2, L3 ).} \\[0.1cm]
müssen wir zwei Bedingungen nachweisen:
\begin{enumerate}
\item $\FV^+\big(\mathtt{concat(L1,L2,L3)}\big) \subseteq \FV^+\big(\mathtt{concat([X|L1],L2,[X|L3])}\big)$
\item $\FV^-\big(\mathtt{concat([X|L1],L2,[X|L3])}\big) \subseteq$ \\
      $\FV^+\big(\mathtt{concat([X|L1],L2,[X|L3])}\big) \cup \FV^-\big(\mathtt{concat(L1,L2,L3)}\big)$
\end{enumerate}
Dies folgt aus 
\begin{enumerate}
\item $\FV^+\big(\mathtt{concat(L1,L2,L3)}\big) = \{ \mathtt{L1}, \mathtt{L2} \}$,
\item $\FV^-\big(\mathtt{concat(L1,L2,L3)}\big) = \{ \mathtt{L3} \}$,
\item $\FV^+\big(\mathtt{concat([X|L1],L2,[X|L3])}\big) = \{ \mathtt{X}, \mathtt{L1}, \mathtt{L2} \}$,
\item $\FV^-\big(\mathtt{concat([X|L1],L2,[X|L3])}\big) = \{ \mathtt{X}, \mathtt{L3} \}$.
\end{enumerate}

Wir schließen diesen Abschnitt mit einer Definition ab.

\begin{Definition}[Funktionales Programm] \hspace*{\fill} \\
{\em
    Es sei $\mathcal{P}$ ein Prolog--Programm und für alle Prädikats--Zeichen aus $\mathcal{P}$ sei eine E/A--Spezifikation gegeben.
    Sind alle Programm--Klausel aus $\mathcal{P}$ mit den gegebenen E/A--Spezifikationen verträglich, so nennen wir $\mathcal{P}$
    \emph{funktional}.
}     \hspace*{\fill} $\Box$  
\end{Definition}

Die Erfahrung zeigt, dass die Einschränkung von Prolog auf funktionale Programme zu einem für die Praxis 
tragfähigen Programmier--Konzept führt.  Im nächsten Abschnitt werden wir einige Beispiele betrachten.
Wir haben dann nämlich ein Konzept, was zwar das ursprüngliche Paradigma des logischen Programmierens deutlich abschwächt, 
aber, wie Satz \ref{vertraelich} zeigt, gerade dadurch handhabbar macht.
Trotz der Abschwächung ist dieses Konzept immer noch wesentlich mächtiger als das Paradigma des 
 funktionale Programmieren, das in Sprachen wir \textsl{Lisp} realisiert ist.
Das liegt daran, dass wir in Prolog auch in den Programmen, die wir als funktional deklariert haben, 
Gebrauch von der systematischen Suche machen können, die in dem Prolog zugrunde liegenden Algorithmus
implementiert ist.

\section{Funktionale Programme: Beispiele}
Wir geben in diesem Abschnitt einige Beispiele für funktionale Programme an.  
Das Ziel ist es dabei, dem Leser ein Gefühl für die Leistungsfähigkeit des im letzten 
Abschnitt vorgestellten Konzeptes zu vermitteln.

\subsection{Ein einfacher Sortier--Algorithmus}
Wir beginnen mit einem einfachen Algorithmus zum Sortieren von Listen von Zahlen.
Das Programm besteht aus zwei Prädikaten:
\begin{enumerate}
\item \texttt{insert} hat die E/A--Spezifikationen \texttt{insert(+,+,-)}.  Es erwartet
      als erstes Argument eine Zahl $x$ und als zweites Argument eine Liste von Zahlen $l$,
      die zusätzlich noch in aufsteigender Reihenfolge sortiert sein muss.

      Das Prädikat fügt die Zahl $x$ so in die Liste $l$ ein, dass die resultierende Liste
      wiederum in aufsteigender Reihenfolge sortiert ist.
\item \texttt{insertion\_sort} hat die E/A--Spezifikationen \texttt{insertion\_sort(+,-)}.
      Es erwartet als Eingabe eine Liste von Zahlen $l$.  Diese Liste wird in aufsteigender Reihenfolge sortiert.
\end{enumerate}
Das komplette Programm ist unten angegeben.

\begin{verbatim}
    % insert( +, +, - ).

    insert( X, [], [ X ] ). 

    insert( X, [ Head | Tail ], [ X, Head | Tail ] ) :-
        X < Head.

    insert( X, [ Head | Tail ], [ Head | New_Tail ] ) :-
        X >= Head,
        insert( X, Tail, New_Tail ).

    % insertion_sort( +, - ).

    insertion_sort( [], [] ).

    insertion_sort( [ Head | Tail ], Sorted ) :-
        insertion_sort( Tail, Sorted_Tail ),
        insert( Head, Sorted_Tail, Sorted ).
\end{verbatim}
Nachfolgend diskutieren wir die einzelnen Klauseln der Implementierung des Prädikats \texttt{insert}.
\begin{enumerate}
\item Die erste Klausel des Prädikats \texttt{insert} greift, wenn die eingegebene Liste leer ist.
      In diesem Fall wird als Ergebnis einfach die Liste zurück gegeben, die als einziges Element
      das Element \texttt{X} enthält, das als erstes Eingabe--Argument eingegeben worden ist.
\item Die zweite Klausel greift, wenn die eingegebene Liste nicht leer ist und wenn außerdem
      das als erstes Argument eingegebene Element \texttt{X} kleiner als das  erste Element \texttt{Head}
      der Liste \texttt{[ Head | Tail |} ist. In diesem Fall kann \texttt{X} an den Anfang der 
      Liste \texttt{[ Head | Tail ]}  gestellt werden: Dann erhalten wir die Liste \texttt{[ X, Head | Tail ]}.
      Diese Liste ist sortiert, weil einerseits schon die Liste \texttt{[ Head | Tail ]} sortiert ist
      und andererseits \texttt{X} kleiner als \texttt{Head} ist.
\item Die dritte Klausel greift, wenn die eingegebene Liste nicht leer ist und wenn außerdem
      das als erstes Argument eingegebene Element \texttt{X} größer oder gleich dem ersten Element \texttt{Head}
      der Liste  \texttt{[ Head | Tail ]} ist.  In diesem Fall muss \texttt{X} 
      in die Liste \texttt{Tail} eingefügt werden.  Das passiert durch den rekursiven Aufruf von \texttt{insert}.
      Dabei entsteht die Liste \texttt{New\_Tail}.  Um das Endergebnis zu erhalten, wird vorne an diese Liste noch das Element
      \texttt{Head} eingefügt.
\end{enumerate}
Damit können wir nun auch die Wirkungsweise des Prädikats \texttt{insertion\_sort} erkären.
\begin{enumerate}
\item Ist die zu sortierende Liste leer, so ist das Ergebnis die leere Liste.
\item Ist die zu sortierende Liste nicht leer und hat die Form \texttt{[Head | Tail]}, so sortieren wir zunächst die
      Liste \texttt{Tail} und erhalten als Ergebnis die sortierte Liste \texttt{Sorted\_Tail}.  Fügen wir hier
      noch das Element \texttt{Head} mit Hilfe von \texttt{insert} ein, so erhalten wir als Endergebnis
      die sortierte Liste.
\end{enumerate}

\subsection{Ein effizienter Sortier--Algorithmus}
Der im letzten Abschnitt vorgestellte Sortier--Algorithmus hat einen Nachteil:  Die Rechenzeit,
die dieser Algorithmus verbraucht, wächst im ungünstigsten Fall quadratisch mit der Länge der zu sortierenden 
Liste.  Wir werden nun einen Algorithmus vorstellen der effizienter ist:  Ist $n$ die Länge der Liste, so wächst bei diesem Algorithmus
der Verbrauch der 
Rechenzeitzeit nur mit dem Faktor $n * \textsl{log}_2(n)$.
Wenn es sich bei der zu sortierenden Liste beispielsweise um ein Telefonbuch mit 1 Millionen Einträgen handelt,
dann ist der relative Unterschied des Rechenzeitzeit--Verbrauchs durch den Faktor $\approx 50\,000$ gegeben.

Der Algorithmus, der  als \emph{Sortieren durch Mischen} bezeichnet wird,
wird durch drei Prädikate implementiert, die wir jetzt der Reihe nach vorstellen.  Das erste Prädikat ist
\texttt{split}:
\begin{verbatim}
    % split( +, -, - ).

    split( [], [], [] ).

    split( [ X ], [ X ], [] ).

    split( [ X, Y | Ys ], [ X | First ], [ Y | Second ] ) :-
        split( Ys, First, Second ).
\end{verbatim}
Ein Aufruf dieses Prädikats hat die Form $\mathtt{split}(l,\mathtt{L1},\mathtt{L2})$, wobei $l$ eine 
beliebige Liste ist.  Die Aufgabe von $\texttt{split}$ ist es, diese Liste in zwei etwa gleich große 
Listen aufzuspalten.  Die Korrektheit der ersten beiden Klauseln von \texttt{split} ist offensichtlich.
Die letzte Klausel ist rekursiv: Um eine Liste der Form \texttt{[ X, Y | Ys ]} in etwa gleich große 
Listen aufzuspalten, wird zunächst die Liste \texttt{Ys} in zwei etwa gleich große Teile aufgespalten.
An den ersten dieser Teile wird \texttt{X} gehängt, an den zweiten \texttt{Y}.

Das nächste Prädikat kann in gewissem Sinne als die Umkehrung von \texttt{split} verstanden werden.
Es bekommt als Eingabe zwei Listen, die zusätzlich sortiert sind.  Die Aufgabe von \textsl{mix} ist es,
diese beiden Listen wieder zu einer Liste zusammenzufassen, die ebenfalls sortiert ist.  Das bezeichnen
wir auch als \emph{mischen} der beiden Listen.
\begin{verbatim}
    % mix( +, +, - ).

    mix( [], Xs, Xs ).
    mix( Xs, [], Xs ).

    mix( [ X | Xs ], [ Y | Ys ], [ X | Rest ] ) :-
        X =< Y,
        mix( Xs, [ Y | Ys ], Rest ).

    mix( [ X | Xs ], [ Y | Ys ], [ Y | Rest ] ) :-
        X > Y,\texttt{
        mix( [ X | Xs ], Ys, Rest ).
\end{verbatim}
Die ersten beiden Klauseln sind trivial.  Die dritte Klausel betrachtet den Fall, dass beide eingegebenen 
Listen
nicht leer sind und zusätzlich das erste Element \texttt{X} der ersten Liste \texttt{[ X | Xs ]} kleiner 
oder gleich dem zweiten Element \texttt{Y} der zweiten Liste \texttt{[ Y | Ys ]} ist.  
Dann wird zunächst der Rest \texttt{Xs} der ersten Liste mit der zweiten Liste gemischt und
an dieses Ergebnis wird dann vorne das Element \texttt{X} eingefügt.   

Die vierte Klausel ist anlog zur dritten Klausel und betrachtet den Fall, dass
das erste Element \texttt{X} der ersten Liste \texttt{[ X | Xs ]} größer als das zweite  Element \texttt{Y} 
der zweiten Liste \texttt{[ Y | Ys ]} ist.
In diesem Fall mischen zuächst die erste Liste mit dem  Rest \texttt{Ys} der zweiten Liste und 
hängen dann \texttt{Y} an dieses Ergebnis vorne an. 

Als letztes betrachten wir die Implementierung des Prädikats \texttt{merge\_sort}, das als Eingabe eine Liste von Zahlen
erwartet und diese sortiert.
\begin{verbatim}
    % merge_sort( +, - ).

    merge_sort( [], [] ).
    merge_sort( [ X ], [ X] ).

    merge_sort( List, Sorted ) :-
        split( List, First, Second ),
        merge_sort( First, First_Sorted ),
        merge_sort( Second, Second_Sorted ),
        mix( First_Sorted, Second_Sorted, Sorted ).
\end{verbatim}
Die ersten beiden Klauseln von \texttt{merge\_sort} sind trivial.
Die dritte Klausel arbeitet nach dem Prinzip \emph{divide--and--conquer}, zu Deutsch: \emph{teile und herrsche}.
Zunächst wird die zu sortierende Liste mit Hilfe von \texttt{split} in zwei etwa gleich große Listen aufgeteilt.
Diese werden beide einzeln sortiert und die resultierenden Listen werden gemischt.  

\subsection{Symbolisches Differenzieren}
Zum Abschluss geben wir noch ein Programm an, mit dem es möglich ist, symbolisch zu differenzieren.
Das Programm ist in Figur \ref{fig:symbolisch-diff} auf Seite \pageref{fig:symbolisch-diff} angegeben.
Um mit diesem Programm zum Beispiel die Ableitung der Funktion \\[0.1cm]
\hspace*{1.3cm} $f(x) = 3 * x^4 + \textsl{sin}(x^2) + 5$ \\[0.1cm]
zu berechnen, könnten wir die folgende Anfrage an ein Prolog--System stellen: \\[0.1cm]
\hspace*{1.3cm} \texttt{diff(3 * x ** 4 + sin(x ** 2) + 5, x, Fs). } \\[0.1cm]
Bei Prolog wird für die Exponentiation der Operator ``\texttt{**}'' verwendet.
Die Antwort, die dann von dem Prolog--System ausgegeben wird, ist \\[0.1cm]
\hspace*{1.3cm} \texttt{FS = 0*x**4+3* (4*1*x**3)+2*1*x**1*cos(x**2)+0} \\[0.1cm]
Schreiben wir dies, ohne ihnhaltlich etwas zu verändern, in der gewohnten mathematischen Notation,
so erhalten wir \\[0.1cm]
\hspace*{1.3cm} $\frac{d\,f}{dx} = 0*x^4+3* (4*1*x^3)+2*1*x^1*\textsl{cos}(x^2)+0$ \\[0.1cm]
Hier fällt natürlich auf, dass dieser Ausdruck noch vereinfacht werden kann.  Es ist ein leichtes,
ein Prolog--Programm zu schreiben, was die benötigten Vereinfachungen durchführt.  Als Endergebnis erhalten wir dann \\[0.1cm]
\hspace*{1.3cm} \hspace*{1.3cm} $\frac{d\,f}{dx} = 12*x^3 +2*x*\textsl{cos}(x^2)$. 

\begin{figure}[!h]
  \centering
\begin{verbatim}
% diff( +, +, - ).

diff( X, X, 1 ).

diff( Y, X, 0 ) :- 
        atom(Y),
        X \== Y.

diff( C, _X, 0 ) :-
        number(C).

diff( - F, X, - DF ) :-
        diff( F, X, DF ).

diff( F + G, X, DF + DG ) :- 
        diff( F, X, DF ), 
        diff( G, X, DG ).

diff( F - G, X, DF - DG) :- 
        diff( F, X, DF ), 
        diff( G, X, DG ).

diff( F * G, X, DF * G + F * DG ) :- 
        diff( F, X, DF ), 
        diff( G, X, DG ).

diff( F / G, X, (DF * G - F * DG) / (G * G) ) :- 
        diff( F, X, DF ), diff( G, X, DG ).

diff( F ** N, X, N * DF * F ** N1 ) :-
        number(N),
        N1 is N - 1,
        diff( F, X, DF ).

diff( exp(F), X, DF * exp(F) ) :- 
        diff( F, X, DF ).

diff( ln(F), X, DF / F ) :- 
        diff( F, X, DF ).

diff( sin(F), X, DF * cos(F) ) :-
        diff(F, X, DF).

diff( cos(F), X, - DF * sin(F) ) :-
        diff(F, X, DF).
\end{verbatim}
  \caption{Ein Programm zum symbolischen Differenzieren}
  \label{fig:symbolisch-diff}
\end{figure}

Wir machen uns nun daran, dass Prolog--Programm im Detail zu diskutieren.
Wir werden zeigen, dass jede Programm--Klausel unmittelbar als Implementierung einer mathematischen
Regel zum symbolischen Differenzieren aufgefasst werden kann.
\begin{enumerate}
\item Die Klausel \\[0.1cm]
      \hspace*{1.3cm} {\tt diff( X, X, 1 ).} \\[0.1cm]
      implementiert die Regel \\[0.1cm]
      \hspace*{1.3cm} $\frac{d\,x}{dx} = 1$.
\item Die Klauseln
      \vspace{-0.3cm}

      \begin{verbatim}
      diff( Y, X, 0 ) :- 
          atom(Y),
          X \== Y.
      diff( C, _X, 0 ) :-
          number(C).
      \end{verbatim}
      \vspace*{-0.7cm}

      implementieren die Regel \\[0.1cm]
      \hspace*{1.3cm} $\frac{d\,c}{dx} = 0$ \quad für jede Konstante $c$. \\[0.1cm]
      Die obigen Regeln machen Gebrauch von den eingebauten einstelligen Prädikaten \texttt{atom}
      und \texttt{number}.  Diese haben die E/A--Spezifikationen \\[0.1cm]
      \hspace*{1.3cm} \texttt{atom(+)} und \texttt{number(+).} \\[0.1cm]
      \texttt{atom(Y)} ist wahr, wenn \texttt{Y} ein Prolog Funktions--Zeichen ist, also ein String,
      der aus Buchstaben und dem Zeichen ``\texttt{\_}'' besteht un der zusätzlich mit einem 
      Kleinbuchstaben anfängt.  Das Prädikat \texttt{number(C)} ist wahr, wenn \texttt{C} eine Zahl ist.
\item Die Klausel
      \vspace*{-0.3cm}

      \begin{verbatim}
      diff( - F, X, - DF ) :-
          diff( F, X, DF ).
      \end{verbatim}
      \vspace*{-0.7cm}

      implementiert die Regel \\[0.1cm]
      \hspace*{1.3cm} $\frac{d}{dx}(-f) = - \frac{d\,f}{dx}$
\item Die Klausel
      \vspace*{-0.3cm}

      \begin{verbatim}
      diff( F + G, X, DF + DG ) :- 
          diff( F, X, DF ), 
          diff( G, X, D ).
      \end{verbatim}
      \vspace*{-0.7cm}

      implementiert die Regel \\[0.1cm]
      \hspace*{1.3cm} $\frac{d}{dx}(f+g) = \frac{d\,f}{dx} + \frac{d\,g}{dx}$
\item Die Klausel
      \vspace*{-0.3cm}

      \begin{verbatim}
      diff( F - G, X, DF - DG) :- 
          diff( F, X, DF ), 
          diff( G, X, DG ).
      \end{verbatim}
      \vspace*{-0.7cm}

      implementiert die Regel \\[0.1cm]
      \hspace*{1.3cm} $\frac{d}{dx}(f-g) = \frac{d\,f}{dx} - \frac{d\,g}{dx}$
\item Die Klausel
      \vspace*{-0.3cm}

      \begin{verbatim}
      diff( F * G, X, DF * G + F * DG ) :- 
          diff( F, X, DF ), 
          diff( G, X, DG ).
      \end{verbatim}
      \vspace*{-0.7cm}

      implementiert die Regel \\[0.1cm]
      \hspace*{1.3cm} $\frac{d}{dx}(f*g) = \frac{d\,f}{dx}*g + f*\frac{d\,g}{dx}$
\item Die Klausel
      \vspace*{-0.3cm}

      \begin{verbatim}
      diff( F / G, X, (DF * G - F * DG) / (G * G) ) :- 
          diff( F, X, DF ),
          diff( G, X, DG ).
      \end{verbatim}
      \vspace*{-0.7cm}

      implementiert die Regel \\[0.1cm]
      \hspace*{1.3cm} $\frac{d}{dx}(f/g) = \frac{\displaystyle \frac{d\,f}{dx}*g - f*\frac{d\,g}{dx}}{\displaystyle g^2}$
\item Die Klausel
      \vspace*{-0.3cm}

      \begin{verbatim}
      diff( F ** N, X, N * DF * F ** N1 ) :-
          number(N),
          N1 is N - 1,
          diff( F, X, DF ).
      \end{verbatim}
      \vspace*{-0.7cm}

      implementiert die Regel \\[0.1cm]
      \hspace*{1.3cm} $\frac{d}{dx} f^n = n * \frac{d\, f}{dx} * f^{n-1}$ \\[0.1cm]
      Bei dieser Regel machen wir Gebrauch von dem zweistelligen Prädikat ``\texttt{is}'',
      das in Prolog eingebaut ist.  Dieses Prädikat darf in Prolog in Infix--Notation angegeben werden.
      Es hat die E/A--Spezifikationen \\[0.1cm]
      \hspace*{1.3cm} {\tt is(-, +)}. \\[0.1cm]
      Es erwartet als zweites Argument einen arithmetischen Ausdruck.  Es wertet diesen Ausdruck aus und gibt
      das Ergebnis im ersten Argument zurück.
\item Die Klausel
      \vspace*{-0.3cm}

      \begin{verbatim}
      diff( exp(F), X, DF * exp(F) ) :- 
          diff( F, X, DF ).
      \end{verbatim}
      \vspace*{-0.7cm}

      implementiert die Regel \\[0.1cm]
      \hspace*{1.3cm} $\frac{d}{dx}\textsl{exp}(f) = \frac{d\,f}{dx}* \textsl{exp}(f)$
\item Die Klausel
      \vspace*{-0.3cm}

      \begin{verbatim}
      diff( ln(F), X, DF / F ) :- 
          diff( F, X, DF ).
      \end{verbatim}
      \vspace*{-0.7cm}

      implementiert die Regel \\[0.1cm]
      \hspace*{1.3cm} $\frac{d}{dx}\textsl{ln}(f) = \frac{d\,f}{dx}* \frac{1}{f}$
\item Die Klausel
      \vspace*{-0.3cm}

      \begin{verbatim}
      diff( sin(F), X, DF * cos(F) ) :-
          diff(F, X, DF).
      \end{verbatim}
      \vspace*{-0.7cm}

      implementiert die Regel \\[0.1cm]
      \hspace*{1.3cm} $\frac{d}{dx}\textsl{sin}(f) = \frac{d\,f}{dx}* \textsl{cos}(f)$
\item Die Klausel
      \vspace*{-0.3cm}

      \begin{verbatim}
      diff( cos(F), X, - DF * sin(F) ) :-
          diff(F, X, DF).
      \end{verbatim}
      \vspace*{-0.7cm}

      implementiert die Regel \\[0.1cm]
      \hspace*{1.3cm} $\frac{d}{dx}\textsl{cos}(f) = - \frac{d\,f}{dx}* \textsl{sin}(f)$
\end{enumerate}
Wir könnten das obige Programm noch dahingehen erweitern, dass wir auch die Umkehrfunktionen der trigonometrischen Funktionen
behandeln.  Würden wir dann noch einige Regeln zur Vereinfachung hinzufügen, würde das Programm etwa auf das doppelte anwachsen.
Es würde dann etwa zwei Seiten in Anspruch nehmen.  Würden sie versuchen, ein solches Programm in einer Sprache wie \texttt{C} zu erstellen,
so würde das entstehende Programm sicherlich wesentlich größer.
Dies zeigt, das Prolog--Programme für bestimmte Anwendungen wesentlich einfacher zu erstellen sind als vergleichbare
Programme in  imperativen Sprachen.  Ein weiterer Vorteil des Prolog--Programms ist, dass es \emph{deklarativ} ist:
die Programm--Klauseln lassen sich unmittelbar als mathematische Formeln interpretieren.  Damit sind (gut geschriebene)
Prolog--Programme wesentlich leichter zu lesen als Programme, die beispielsweise in \texttt{C} erstellt werden.





%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "informatik-script"
%%% End: 
